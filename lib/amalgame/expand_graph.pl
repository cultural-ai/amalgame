:- module(expand_graph,
	  [ expand_mapping/2,
	    expand_vocab/2,
	    flush_expand_cache/0,
	    flush_expand_cache/1,     % +Id
	    process_options/3,
	    save_mappings/2
	  ]).

:- use_module(library(semweb/rdf_db)).
:- use_module(library(semweb/rdf_turtle_write)).
:- use_module(library(semweb/rdfs)).
:- use_module(library(http/http_parameters)).
:- use_module(library(amalgame/amalgame_modules)).
:- use_module(library(amalgame/map)).
:- use_module(library(amalgame/opm)).

:- dynamic
	expand_cache/2.

:- setting(cache_time, float, 0.5,
	   'Minimum execution time to cache results').

%%	expand_mapping(+Id, -Result) is det.
%
%	Generate the Result corresponding to Id.
%	We use a mutex so that the next thread will use the cached
%	version.
%
%	@param Id
%          if Id is a Mapping Result is [align(c1,c2,prov)]
%          if Id is a Vocabulary Result is an assoc or one of
%          scheme(Scheme) or type(Class)

expand_mapping(Id, Mapping) :-
	rdf_has(Id, opmv:wasGeneratedBy, Process, OutputType),
	rdf(Id, OutputType, Process, StrategyGraph:_),
	!,
	prov_graph(StrategyGraph, ProvenanceGraph),
	with_mutex(Process, expand_process(Process, Result,
					   [prov(ProvenanceGraph),
					    strategy(StrategyGraph)
					   ])),
	select_result_mapping(Result, OutputType, Mapping),
	length(Mapping, Count),
	debug(ag_expand, 'Found ~w mappings for ~p', [Count, Id]),
	materialize_if_needed(Id, Mapping).

%%	expand_vocab(+Id, -Concepts) is det.
%
%	Generate the Vocab.
%	@param Id is URI of a conceptscheme or an identifier for a set
%	of concepts derived by a vocabulary process,

expand_vocab(Id, Vocab) :-
	rdf_has(Id, opmv:wasGeneratedBy, Process, RealProp),
	rdf(Id, RealProp, Process, StrategyGraph:_),
	!,
	prov_graph(StrategyGraph, PGraph),
	with_mutex(Process, expand_process(Process, Vocab,
					   [prov(PGraph),
					   strategy(StrategyGraph)])).
expand_vocab(Vocab, Vocab).

%%	expand_process(+Process, -Result, +Options)
%
%	Expand process to generate Result
%
%	Results are cached when execution time eof process takes longer
%	then setting(cache_time).

expand_process(Process, Result, _) :-
	ground(Process),
	expand_cache(Process, Result),
	!,
	debug(ag_expand, 'Output of process ~p taken from cache', [Process]).
expand_process(Process, Result, GlobalOptions) :-
	rdf(Process, rdf:type, Type),
	!,
	amalgame_module_id(Type, Module),
	process_options(Process, Module, ProcOptions),
	append(ProcOptions, GlobalOptions, Options),
	exec_amalgame_process(Type, Process, Module, Result, Time, Options),
	findall(Artifact, rdf_has(Artifact, opmv:wasGeneratedBy, Process), Artifacts),
	option(prov(ProvenanceGraph), GlobalOptions, test_prov),
	option(strategy(StrategyGraph), GlobalOptions, test_strat),
	add_amalgame_opm(Process, Artifacts, StrategyGraph, ProvenanceGraph),
	opm_was_generated_by(Process, Artifacts, ProvenanceGraph, [ptime(Time)]),
	cache_expand_result(Time, Process, Result),
	debug(ag_expand, 'Output of process ~p (~p) computed in ~ws',
	      [Process,Type,Time]).

cache_expand_result(ExecTime, Process, Result) :-
	setting(cache_time, CacheTime),
	ExecTime > CacheTime,
	!,
	assert(expand_cache(Process, Result)).
cache_expand_result(_, _, _).

%%	flush_expand_cache(+Id)
%
%	Retract all cached mappings.

flush_expand_cache :-
	del_prov_graphs,
	del_materialized_finals,
	forall(expand_cache(Id, _),
	       flush_expand_cache(Id)).


flush_expand_cache(Id) :-
	expand_cache(Id, _), % make sure Id is bounded to something in the cache
	retractall(expand_cache(Id, _)),
	catch(rdf_unload(Id), _, true),
	debug(ag_expand, 'flush cache and unloading graph for ~p', [Id]).

del_prov_graphs :-
	findall(P,prov_graph(_,P), ProvGraphs),
	forall(member(P, ProvGraphs), catch(rdf_unload(P), _, true)).

del_materialized_finals :-
	findall(Id, (
		    rdf(Id, amalgame:status, amalgame:final),
		     rdfs_individual_of(Id, amalgame:'Mapping')
		    ), Finals),
	forall(member(F, Finals), catch(rdf_unload(F), _, true)).

%%	exec_amalgame_process(+Type, +Process, +Module, -Result,
%%	+Options)
%
%	Result is generated by executing Process of type Type.
%
%	@error existence_error(mapping_process)

exec_amalgame_process(Type, Process, Module, Mapping, Time, Options) :-
	rdfs_subclass_of(Type, amalgame:'Matcher'),
	!,
	(   rdf(Process, amalgame:source, SourceId),
	    rdf(Process, amalgame:target, TargetId)
	->  expand_vocab(SourceId, Source),
	    expand_vocab(TargetId, Target),
	    timed_call(Module:matcher(Source, Target, Mapping0, Options), Time)
	;   rdf(Process, amalgame:input, InputId)
	->  expand_mapping(InputId, MappingIn),
	    timed_call(Module:filter(MappingIn, Mapping0, Options), Time)
	),
	merge_provenance(Mapping0, Mapping).
exec_amalgame_process(Class, Process, Module, Result, Time, Options) :-
	rdfs_subclass_of(Class, amalgame:'VocExclude'),
	!,
	once(rdf(Process, amalgame:input, Input)),
	expand_vocab(Input, Vocab),
	findall(S, rdf(Process, amalgame:exclude, S), Ss),
	maplist(expand_mapping, Ss, Expanded),
	append(Expanded, Mapping),
	timed_call(Module:exclude(Vocab, Mapping, Result, Options), Time).
exec_amalgame_process(Class, Process, Module, Result, Time, Options) :-
	rdfs_subclass_of(Class, amalgame:'MappingSelecter'),
	!,
	Result = select(Selected, Discarded, Undecided),
	once(rdf(Process, amalgame:input, InputId)),
	expand_mapping(InputId, MappingIn),
	timed_call(Module:selecter(MappingIn, Selected, Discarded, Undecided, Options), Time).
exec_amalgame_process(Class, Process, Module, Result, Time, Options) :-
	rdfs_subclass_of(Class, amalgame:'VocabSelecter'),
	!,
	once(rdf(Process, amalgame:input, Input)),
	expand_vocab(Input, Vocab),
	timed_call(Module:selecter(Vocab, Result, Options), Time).
exec_amalgame_process(Class, Process, Module, Result, Time, Options) :-
	rdfs_subclass_of(Class, amalgame:'Merger'),
	!,
	findall(Input, rdf(Process, amalgame:input, Input), Inputs),
	maplist(expand_mapping, Inputs, Expanded),
	timed_call(Module:merger(Expanded, Result, Options), Time).
exec_amalgame_process(Class, Process, _, _, _, _) :-
	throw(error(existence_error(mapping_process, [Class, Process]), _)).

timed_call(Goal, Time) :-
	thread_self(Me),
        thread_statistics(Me, cputime, T0),
	call(Goal),
	thread_statistics(Me, cputime, T1),
        Time is T1 - T0.


%%	select_result_mapping(+ProcessResult, +OutputType, -Mapping)
%
%	Mapping is part of ProcessResult as defined by OutputType.
%
%	@param OutputType is an RDF property
%	@error existence_error(mapping_select)

select_result_mapping(select(Selected, Discarded, Undecided), OutputType, Mapping) :-
	!,
	(   rdf_equal(amalgame:selectedBy, OutputType)
	->  Mapping = Selected
	;   rdf_equal(amalgame:discardedBy, OutputType)
	->  Mapping = Discarded
	;   rdf_equal(amalgame:undecidedBy, OutputType)
	->  Mapping = Undecided
	;   throw(error(existence_error(mapping_selector, OutputType), _))
	).
select_result_mapping(Mapping, P, Mapping) :-
	is_list(Mapping),
	rdf_equal(opmv:wasGeneratedBy, P).

%%	process_options(+Process, +Module, -Options)
%
%	Options are the instantiated parameters for Module based on the
%	parameters string in Process.

process_options(Process, Module, Options) :-
	rdf(Process, amalgame:parameters, literal(ParamString)),
	!,
	module_options(Module, Options, Parameters),
	parse_url_search(ParamString, Search),
	Request = [search(Search)] ,
	http_parameters(Request, Parameters).
process_options(_, _, []).


%%	module_options(+Module, -Options, -Parameters)
%
%	Options  are  all  option  clauses    defined   for  Module.
%	Parameters is a specification list for http_parameters/3.
%	Module:parameter is called as:
%
%	    parameter(Name, Properties, Description)
%
%	Name is the name of the	the option, The Properties are as
%	supported by http_parameters/3.	Description is used by the help
%	system.

module_options(Module, Options, Parameters) :-
	current_predicate(Module:parameter/4),
	!,
	findall(O-P,
		( call(Module:parameter, Name, Type, Default, _Description),
		  O =.. [Name, Value],
		  param_options(Type, Default, ParamOptions),
		  P =.. [Name, Value, ParamOptions]
		),
		Pairs),
	pairs_keys_values(Pairs, Options, Parameters).
module_options(_, _, []).


param_options(Type, Default, Options) :-
	(   is_list(Type)
	->  Options = [default(Default)|Type]
	;   Options = [default(Default), Type]
	).

%%	materialize_if_needed(+Id, Mapping) is det.
%
%	materialize result in Mapping in named graph Id if this graph
%	this graph does not exist yet and if the resource with the same
%	Id has the amalgame:status amalgame:final.

materialize_if_needed(Id, _) :-
	rdf_graph(Id), !.
materialize_if_needed(Id, _) :-
	rdf_has(Id, amalgame:status, Status),
	\+ rdf_equal(Status, amalgame:final),
	!.
materialize_if_needed(Id, Mapping) :-
	(   rdf_has(Id, amalgame:recordEvidence, amalgame:enabled)
	->  Enabled = enabled
	;   Enabled = disabled
	),
	materialize_mapping_graph(Mapping, [graph(Id), evidence_graphs(Enabled)]).

save_mappings(Strategy, Options) :-
	prov_graph(Strategy, ProvGraph),
	select_mappings_to_be_saved(Strategy, Mappings, Options),
	forall(member(Mapping, Mappings), save_mapping(Mapping, Strategy,ProvGraph,Options)).

save_mapping(Id, Strategy, ProvGraph, Options) :-
	(   \+ rdf_graph(Id)
	->  expand_mapping(Id, Mapping),
	    materialize_mapping_graph(Mapping, [graph(Id)])
	;   true
	),
	rdf_assert(Id, amalgame:strategy, Strategy, Id),
	rdf_assert(Id, amalgame:opm,      ProvGraph, Id),
	file_base_name(Id, Base),
	file_name_extension(Base, ttl, Name),
	rdf_save_turtle(Name, [graph(Id)|Options]).


select_mappings_to_be_saved(Graph, Mappings, Options) :-
	option(status(Status), Options, all),
	(   Status == all
	->  findall(Mapping,
		    rdf(Mapping, rdf:type, amalgame:'Mapping', Graph),
		    Mappings)
	;   findall(Mapping, (
		rdf(Mapping, rdf:type, amalgame:'Mapping', Graph),
		rdf(Mapping, amalgame:status, Status)
	      ), Mappings)
	).


prov_graph(Strategy, Graph) :-
	rdf(Graph, amalgame:strategy, Strategy, Graph),
	!.

prov_graph(Strategy, Graph) :-
	ground(Strategy),
	format(atom(Label), 'Provenance graph for strategy ~p', [Strategy]),
	rdf_bnode(Graph),
	rdf_assert(Graph, amalgame:strategy, Strategy, Graph),
	rdf_assert(Graph, rdfs:label, literal(lang(en,Label)), Graph),
	% Copy Strategy triples to empty prov graph:
	findall(rdf(Strategy,P,O), rdf(Strategy,P,O,Strategy), STriples),
	forall(member(rdf(S,P,O), STriples), rdf_assert(S,P,O,Graph)).


add_amalgame_opm(Process, Artifacts, Strategy, ProvGraph) :-
	remove_old_prov(Process, ProvGraph),
	rdf_equal(opmv:used, OpmvUsed),
	rdf_equal(opmv:wasDerivedFrom, OpmvWDF),
	findall(rdf(Process, P, O), rdf(Process,P,O,Strategy), ProcessTriples),
	findall(rdf(S,P,O),
		(   member(S, Artifacts),
		    rdf(S,P,O,Strategy)
		), ArtifactTriples),
	findall(rdf(Process, OpmvUsed, S),
		(   rdf_has(Process, OpmvUsed, S, RealProp),
		    rdf(Process, RealProp, S, Strategy)
		),
		InputTriples),
	findall(rdf(Target, OpmvWDF, Source),
		(   member(Target, Artifacts),
		    rdf_has(Process, opmv:used, Source, RealProp),
		    rdf(Process, RealProp, S, Strategy)
		),
		DerivedTriples),
	append([ProcessTriples,
		ArtifactTriples,
		InputTriples,
		DerivedTriples], AllTriples),
	forall(member(rdf(S,P,O), AllTriples), rdf_assert(S,P,O,ProvGraph)).


remove_old_prov(Process, ProvGraph) :-
	findall(Bnode,
		(   rdf(Process, _, Bnode, ProvGraph),
		    rdf_is_bnode(Bnode)
		),
		Bnodes),
	forall(member(B,Bnodes), rdf_retractall(B,_,_,ProvGraph)),
	rdf_retractall(Process, _, _, ProvGraph),
	rdf_retractall(_, _ ,Process, ProvGraph).
