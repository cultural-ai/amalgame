:- module(expand_graph,
	  []).

:- use_module(library(semweb/rdfs)).
:- use_module(library(http/http_parameters)).
:- use_module(library(amalgame/amalgame_modules)).

:- dynamic
	mapping_cache/2.


%%	expand_mapping(+Id, -Mapping:[align(s,t,prov)]) is det.
%
%	Generate the Mapping.
%	@param
%	 Id = URI of Mapping

expand_mapping(Id, Mapping) :-
	mapping_cache(Id, Mapping),
	!.
expand_mapping(Id, Mapping) :-
	rdf_has(Id, opmv:wasGeneratedBy, Process, OutputType),
	rdf(Process, rdf:type, Type),
	amalgame_module_def(Class, Type, Module),
	process_options(Process, Module, Options),
	exec_mapping_process(Class, Process, Module, Results, Options),
	cache_mapping_result(Class, Results, Id),
 	select_result_mapping(OutputType, Results, Mapping).

cache_mapping_result(Class, Mapping, Id) :-
	rdfs_subclass_of(Class, amalgame:'Matcher'),
	assert(mapping_cache(Id, Mapping)).


%%	expand_vocab(+Id, -Concepts) is det.
%
%	Generate the Vocab.
%	@param
%	 Id = URI of Vocab,
%	 or @TBD vocab query definition.

expand_vocab(Id, Concepts) :-
	rdf_has(Id, opmv:wasGeneratedBy, Process),
	exec_vocab_process(Process, Id, Concepts).

%%	exec_mapping_process(+Class, +Process, +Module, -Mapping,
%	+Options)
%
%	Mapping is the mapping corresponding to Id and is generated by
%	executing Process

exec_mapping_process(Class, Process, Module, Mapping, Options) :-
	rdfs_subclass_of(Class, amalgame:'Matcher'),
	!,
 	(   rdf(Process, amalgame:input, InputId)
	->  expand_mapping(InputId, MappingIn),
	    call(Module:filter, MappingIn, Mapping0, Options)
	;   rdf(Process, amalgame:source, SourceId),
	    rdf(Process, amalgame:target, TargetId)
	->  expand_vocab(SourceId, Source),
	    expand_vocab(TargetId, Target),
	    call(Module:matcher, Source, Target, Mapping0, Options)
	),
	merge_provenance(Mapping0, Mapping).

exec_mapping_process(Class, Process, Module, Result, Options) :-
	rdfs_subclass_of(Class, amalgame:'Selecter'),
	!,
	Result = select(Selected, Discarded, Undecided),
 	rdf(Process, amalgame:input, InputId),
	expand_mapping(InputId, MappingIn),
 	length(MappingIn, N0),
	debug(align, 'Running ~w select on ~p with ~w correspondences', [Module, MappingIn, N0]),
 	call(Module:selecter, MappingIn, Selected, Discarded, Undecided, Options).


%%	select_result_mapping(+ProcessResult, +OutputType, -MappingOut)
%
%

select_result_mapping(Mapping, P, Mapping) :-
	is_list(Mapping),
	rdf_equal(opmv:wasGeneratedBy, P),
	!.
select_result_mapping(select(Selected, Discarded, Undecided), OutputType, Mapping) :-
	!,
	(   rdf_equal(amalgame:selectedBy, OutputType)
	->  Mapping = Selected
	;   rdf_equal(amalgame:discardedBy, OutputType)
	->  Mapping = Discarded
	;   rdf_equal(amalgame:untouchedBy, OutputType)
	->  Mapping = Undecided
	).


%%	process_options(+Process, +Module, -Options)
%
%	Options are the instantiated parameters for Module based on the
%	parameters string in Process.

process_options(Process, Module, Options) :-
	rdf(Process, amalgame:parameters, literal(ParamString)),
	!,
	module_options(Module, Options, Parameters),
	parse_url_search(ParamString, Search),
	Request = [search(Search)] ,
	http_parameters(Request, Parameters).
process_options(_, _, []).

%%	module_options(+Module, -Options, -Parameters)
%
%	Options  are  all  option  clauses    defined   for  Module.
%	Parameters is a specification list for http_parameters/3.
%	Module:parameter is called as:
%
%	    parameter(Name, Properties, Description)
%
%	Name is the name of the	the option, The Properties are as
%	supported by http_parameters/3.	Description is used by the help
%	system.

module_options(Module, Options, Parameters) :-
	findall(O-P,
		( call(Module:parameter, Name, Properties, _Description),
		  O =.. [Name, Value],
		  P =.. [Name, Value, Properties]
		),
		Pairs),
	pairs_keys_values(Pairs, Options, Parameters).

%%	http:convert_parameter(+Type, +In, -URI) is semidet.
%
%	HTTP parameter conversion for the following types:
%
%	    * uri
%	    This  conversion  accepts NS:Local and absolute URIs.

http:convert_parameter(uri, In, URI) :-
	(   sub_atom(In, B, _, A, :),
	    sub_atom(In, _, A, 0, Local),
	    xml_name(Local)
	->  sub_atom(In, 0, B, _, NS),
	    rdf_global_id(NS:Local, URI)
	;   is_absolute_url(In)
	->  URI = In
	).


%%	merge_provenance(+AlignIn, -AlignOut)
%
%	Collects all provenance for similar source target pairs.
%	AlignIn is a sorted list of align/3 terms.

merge_provenance([], []).
merge_provenance([align(S, T, P)|As], Gs) :-
	group_provenance(As, S, T, P, Gs).

group_provenance([align(S,T,P)|As], S, T, P0, Gs) :-
	!,
	append(P, P0, P1),
	group_provenance(As, S, T, P1, Gs).
group_provenance(As, S, T, P, [align(S, T, Psorted)|Gs]) :-
	sort(P, Psorted),
	merge_provenance(As, Gs).
